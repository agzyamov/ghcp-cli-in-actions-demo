# Copilot Response

**Question:** How do I implement rate limiting in Python?

**Asked:** 2025-10-17 11:29:03 UTC

---

â— Here are several approaches to implement rate limiting in Python:

   **1. Using a decorator with time-based throttling:**

   ```python
   import time
   from functools import wraps

   def rate_limit(max_calls, time_window):
       """Limit function calls to max_calls per time_window seconds"""
       calls = []

       def decorator(func):
           @wraps(func)
           def wrapper(*args, **kwargs):
               now = time.time()
               # Remove calls outside the time window
               calls[:] = [c for c in calls if c > now - time_window]

               if len(calls) >= max_calls:
                   sleep_time = time_window - (now - calls[0])
                   time.sleep(sleep_time)
                   calls[:] = []

               calls.append(time.time())
               return func(*args, **kwargs)
           return wrapper
       return decorator

   # Usage
   @rate_limit(max_calls=5, time_window=60)
   def api_call():
       print("API called")
   ```

   **2. Using the `ratelimit` library:**

   ```python
   from ratelimit import limits, sleep_and_retry

   # Allow 10 calls per minute
   @sleep_and_retry
   @limits(calls=10, period=60)
   def call_api():
       # Your API call here
       pass
   ```

   **3. Token bucket algorithm:**

   ```python
   import time
   import threading

   class TokenBucket:
       def __init__(self, tokens, fill_rate):
           self.capacity = tokens
           self.tokens = tokens
           self.fill_rate = fill_rate
           self.timestamp = time.time()
           self.lock = threading.Lock()

       def consume(self, tokens=1):
           with self.lock:
               now = time.time()
               # Add tokens based on time passed
               self.tokens += (now - self.timestamp) * self.fill_rate
               self.tokens = min(self.tokens, self.capacity)
               self.timestamp = now

               if self.tokens >= tokens:
                   self.tokens -= tokens
                   return True
               return False

   # Usage
   bucket = TokenBucket(tokens=10, fill_rate=1)  # 10 tokens, refill at 1/sec
   if bucket.consume():
       # Proceed with operation
       pass
   ```

   **4. For web APIs using Flask-Limiter:**

   ```python
   from flask import Flask
   from flask_limiter import Limiter
   from flask_limiter.util import get_remote_address

   app = Flask(__name__)
   limiter = Limiter(
       app=app,
       key_func=get_remote_address,
       default_limits=["200 per day", "50 per hour"]
   )

   @app.route("/api")
   @limiter.limit("10 per minute")
   def api_endpoint():
       return "Response"
   ```

   The best approach depends on your use case: simple decorators for basic throttling, token bucket
    for smooth rate limiting, or dedicated libraries for production web applications.


Total usage est:       1 Premium request
Total duration (API):  12.2s
Total duration (wall): 13.8s
Total code changes:    0 lines added, 0 lines removed
Usage by model:
    claude-sonnet-4.5    0 input, 0 output, 0 cache read, 0 cache write (Est. 0 Premium requests)
